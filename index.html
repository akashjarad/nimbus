<!DOCTYPE html>
<html>

  <head>
    <title>Nimbus</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <!-- Underscore and other utilities -->
    <script src="js/underscore.js"></script>

    <!-- Three.js and libraries -->
    <script src="js/three.min.js"></script>
    <script src="js/stats.min.js"></script>

    <!-- Objects -->
    <script src="js/locus.js"></script>
    <script src="js/objects.js"></script>

    <!-- Reset CSS styles -->
    <link href="css/reset.css" rel="stylesheet">

  </head>

  <body>

<script>

      var container, stats;

      var camera, controls, scene, projector, renderer;
      var geometry, material, mesh;
      var objects = [], plane;

      var mouse = new THREE.Vector2(),
      offset = new THREE.Vector3(),
      INTERSECTED, SELECTED;

      init();
      animate();

      var start = Date.now();
      var rate = 10; // Hz
      var duration = 10; // s
      var lastFrameNumber;



      function init() {

          container = document.createElement( 'div' );
          document.body.appendChild( container );

          //camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 500, 1000 );
          camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000);
          scene = new THREE.Scene();

          // Mark the origin

          drawOriginMarker(scene, 500);

          // Grid
          var size = 750, step = 75;
          var geometry = new THREE.Geometry();
          for ( var i = - size; i <= size; i += step ) {
            geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
            geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );
            geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
            geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );
          }
          var gridMaterial = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.1 } );
          var line = new THREE.Line( geometry, gridMaterial );
          line.type = THREE.LinePieces;
          scene.add( line );

          // Add some ambient light
          var ambientLight = new THREE.AmbientLight(0x555555);
          scene.add(ambientLight);

          // Cubes
          var cubes = [];

          cubes.push( createCube(75, 42.75, 75, 0, -75, 0.6) );
          cubes.push( createCube(75, 67.5, 175, 0, -75) );

          cubes.push( createCube(75, 67.5, 275, 0, -75) );
          cubes.push( createCube(75, 42.75, 375, 0, -75) );
          cubes.push( createCube(75, 42.75, 75, 0, 175) );
          cubes.push( createCube(75, 67.5, 175, 0, 175) );
          cubes.push( createCube(75, 67.5, 275, 0, 175) );
          cubes.push( createCube(75, 42.75, 375, 0, 175) );

          cubes.push( createCube(75, 37.5, 75, 0, 275) );
          cubes.push( createCube(75, 42.75, 175, 0, 275, 0.6) );
          cubes.push( createCube(75, 67.5, 275, 0, 275, 0.6) );
          cubes.push( createCube(75, 90, 375, 0, 275) );

          cubes.push( createCube(75, 75, -175, 0, 275, 0.6) );

          // Add cubes to scene
          _.each(cubes, function(cube) {

            // Add cube object to the scene
            scene.add( cube );

            // and our list of objects for intersection mapping
            _.each(cube.children, function(child) {
              if (child instanceof THREE.Mesh) {
                objects.push(child)
              }
            });

          });

          // point indicator
          /*
          geometry = new THREE.CubeGeometry( 5, 5, 5 );
          cubeMaterial = new THREE.MeshBasicMaterial( { color: 0xCC0000, wireframe: false, opacity: 1 } );

          mesh = new THREE.Mesh( geometry, cubeMaterial );

          mesh.position.x = 50;
          mesh.position.y = 25;
          mesh.position.z = 50;

          scene.add( mesh );
          */

          //plane = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.25, transparent: true, wireframe: true } ) );
          //plane.visible = false;
          //scene.add( plane );

          projector = new THREE.Projector();

          renderer = new THREE.WebGLRenderer( { antialias: true } );
          renderer.setSize( window.innerWidth, window.innerHeight );

          container.appendChild( renderer.domElement );

          stats = new Stats();
          stats.domElement.style.position = 'absolute';
          stats.domElement.style.top = '0px';
          container.appendChild( stats.domElement );

          renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );

          window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
        render();

      }

      function animate() {
        var elapsed = Date.now() - start;
        if (elapsed > duration * 1000) {
          //console.log("skipped")
          //return;
        }

        setTimeout( function() {
          requestAnimationFrame( animate );
        }, 1000 / rate );

        render();
        stats.update();
      }


      function render() {

        var timer = Date.now() * 0.0001;

        camera.position.x = 120; //Math.cos( timer ) * 200;
        camera.position.y = 94;
        camera.position.z = 120; //Math.sin( timer ) * 200;



        camera.position.x = 800; //Math.cos( timer ) * 200;
        camera.position.y = 500;
        camera.position.z = 800; //Math.sin( timer ) * 200;



        camera.lookAt( scene.position );

        renderer.render( scene, camera );

      }


      function onDocumentMouseMove( event ) {

        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        //

        console.log (mouse.x + " " + mouse.y)

        var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
        projector.unprojectVector( vector, camera );

        var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

        if ( SELECTED ) {

          var intersects = raycaster.intersectObject( plane );
          SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );
          return;

        }


        var intersects = raycaster.intersectObjects( objects, true );

        console.log(intersects)

        if ( intersects.length > 0 ) {

          console.log('yup!');

          if ( INTERSECTED != intersects[ 0 ].object ) {

            if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

            INTERSECTED = intersects[ 0 ].object;
            INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

            INTERSECTED.material.color.setHex(130000)

            //plane.position.copy( INTERSECTED.position );
            //plane.lookAt( camera.position );

          }

          container.style.cursor = 'pointer';

        } else {

          if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

          INTERSECTED = null;

          container.style.cursor = 'auto';

        }

      }


    </script>
  </body>
</html>