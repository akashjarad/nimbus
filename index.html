<!DOCTYPE html>
<html>

  <head>
    <title>Nimbus</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <!-- Underscore and other utilities -->
    <script src="js/underscore.js"></script>

    <!-- Three.js and libraries -->
    <script src="js/three.min.js"></script>
    <script src="js/stats.min.js"></script>
    <script src="js/controls/TrackballControls.js"></script>

    <!-- Objects -->
    <script src="js/locus.js"></script>
    <script src="js/objects.js"></script>
    <script src="js/aws.js"></script>

    <!-- Reset CSS styles -->
    <link href="css/reset.css" rel="stylesheet">

  </head>

  <body>

<script>

      var container, stats;

      var camera, controls, scene, projector, renderer;
      var geometry, material, mesh;
      var objects = [], plane;

      var mouse = new THREE.Vector2(),
      offset = new THREE.Vector3(),
      INTERSECTED, SELECTED;

      init();
      animate();

      var start = Date.now();
      var rate = 10; // Hz
      var duration = 10; // s
      var lastFrameNumber;



      function init() {

          // Create a container to hold all our cruft
          container = document.createElement( 'div' );
          document.body.appendChild( container );

          //camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 500, 1000 );
          camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000);

          scene = new THREE.Scene();

          // Isometric projection camera locations
          //camera.position.x = 120; //Math.cos( timer ) * 200;
          //camera.position.y = 94;
          //camera.position.z = 120; //Math.sin( timer ) * 200;

          // Perspective projection camera position
          camera.position.x = 800; //Math.cos( Date.now() ) * 200;
          camera.position.y = 600;
          camera.position.z = 800; //Math.sin( timer ) * 200;

          // Look at the centre of the scene
          camera.lookAt( scene.position );

          // Add camera controls
          controls = new THREE.TrackballControls( camera );
          controls.rotateSpeed = 1.0;
          controls.zoomSpeed = 1.2;
          controls.panSpeed = 0.8;
          controls.noZoom = false;
          controls.noPan = false;
          controls.staticMoving = true;
          controls.dynamicDampingFactor = 0.3;
          controls.keys = [ 65, 83, 68 ];
          controls.addEventListener( 'change', render );

          // Mark the origin
          drawOriginMarker(scene, 500);

          // Grid
          var size = 750, step = 75;
          var geometry = new THREE.Geometry();
          for ( var i = - size; i <= size; i += step ) {
            geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
            geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );
            geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
            geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );
          }
          var gridMaterial = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.1 } );
          var line = new THREE.Line( geometry, gridMaterial );
          line.type = THREE.LinePieces;
          scene.add( line );

          // Add some ambient light
          var ambientLight = new THREE.AmbientLight(0x555555);
          scene.add(ambientLight);

          // Build our scene
          var items = [];

          items.push( createCube(75, 42.75, 75, 0, -75, 0.6) );
          items.push( createCube(75, 67.5, 175, 0, -75) );
          //items.push( createCube(75, 42.75, 75, 0, 175) );
          //items.push( createCube(75, 67.5, 175, 0, 175) );
          //items.push( createCube(75, 67.5, 275, 0, 175) );
          //items.push( createCube(75, 42.75, 375, 0, 175) );
          //items.push( createCube(75, 37.5, 75, 0, 275) );
          //items.push( createCube(75, 42.75, 175, 0, 275, 0.6) );
          //items.push( createCube(75, 67.5, 275, 0, 275, 0.6) );
          //items.push( createCube(75, 90, 375, 0, 275) );
          //items.push( createCube(75, 75, -175, 0, 275, 0.6) );

          items.push( ec2Instance( { "size": "small", "x": 0, "z": 200 } ));

          // Worker nodes (stacked)
          items.push( createCube(75, 37.5, 375, 0, -75) );
          items.push( createCube(75, 37.5, 375, 55, -75) );
          items.push( createCube(75, 37.5, 470, 0, -75) );
          items.push( createCube(75, 37.5, 470, 55, -75) );

          // ELB
          items.push( createOctagon(scene, 75, 37.5, 175, 0, 175, 1) );

          // Add scene items to scene
          _.each(items, function(item) {

            // Add object to the scene
            scene.add( item );

            // and our list of objects for intersection mapping
            _.each(item.children, function(child) {
              if (child instanceof THREE.Mesh) {
                objects.push(child)
              }
            });

          });

          // point indicator
          /*
          geometry = new THREE.CubeGeometry( 5, 5, 5 );
          cubeMaterial = new THREE.MeshBasicMaterial( { color: 0xCC0000, wireframe: false, opacity: 1 } );

          mesh = new THREE.Mesh( geometry, cubeMaterial );

          mesh.position.x = 50;
          mesh.position.y = 25;
          mesh.position.z = 50;

          scene.add( mesh );
          */

          // Build projector & renderer and attach
          projector = new THREE.Projector();
          renderer = new THREE.WebGLRenderer( { antialias: true } );
          renderer.setSize( window.innerWidth, window.innerHeight );
          container.appendChild( renderer.domElement );

          // Display FPS counter
          stats = new Stats();
          stats.domElement.style.position = 'absolute';
          stats.domElement.style.top = '0px';
          container.appendChild( stats.domElement );

          // Events
          renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
          window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        controls.handleResize();

        render();
      }

      function animate() {
        var elapsed = Date.now() - start;
        if (elapsed > duration * 1000) {
          //console.log("skipped")
          //return;
        }

        setTimeout( function() {
          requestAnimationFrame( animate );
          controls.update();
        }, 1000 / rate );

        render();
        stats.update();
      }


      function render() {
        renderer.render( scene, camera );
      }


      function onDocumentMouseMove( event ) {

        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
        projector.unprojectVector( vector, camera );

        var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

        var intersects = raycaster.intersectObjects( objects, true );

        if ( intersects.length > 0 ) {

          console.log('intersected object!');

          if ( INTERSECTED != intersects[ 0 ].object ) {

            if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

            INTERSECTED = intersects[ 0 ].object;
            INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

            INTERSECTED.material.color.setHex(130000)

          }

          container.style.cursor = 'pointer';

        } else {

          if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

          INTERSECTED = null;

          container.style.cursor = 'auto';

        }

      }


    </script>
  </body>
</html>