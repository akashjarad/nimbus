<!DOCTYPE html>
<html>

  <head>
    <title>Nimbus</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <script src="js/three.min.js"></script>
    <script src="js/stats.min.js"></script>
  </head>

  <body>

<script>

      var container, stats;

      var camera, scene, renderer;
      var geometry, material, mesh;

      init();
      animate();

      var start = Date.now();
      var rate = 10; // Hz
      var duration = 10; // s
      var lastFrameNumber;



      function init() {

          container = document.createElement( 'div' );
          document.body.appendChild( container );

          camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 500, 1000 );
          camera.position.x = 200;
          camera.position.y = 100;
          camera.position.z = 200;

          scene = new THREE.Scene();

          // Grid

          var size = 500, step = 50;

          var geometry = new THREE.Geometry();

          for ( var i = - size; i <= size; i += step ) {

            geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
            geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );

            geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
            geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );

          }

          var gridMaterial = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2 } );

          var line = new THREE.Line( geometry, gridMaterial );
          line.type = THREE.LinePieces;
          scene.add( line );

          // Cube 1

          geometry = new THREE.CubeGeometry( 50, 28.5, 50 );
          cubeMaterial = new THREE.MeshBasicMaterial( { color: 0xEBEBEC, wireframe: false, opacity: 1 } );

          mesh = new THREE.Mesh( geometry, cubeMaterial );

          mesh.position.x = 25;
          mesh.position.y = 14.25;
          mesh.position.z = 25;

          scene.add( mesh );

          // Outline

          var lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 5 });

          var geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3(50, 0, 0));
          geometry.vertices.push(new THREE.Vector3(50, 28.5, 0));
          geometry.vertices.push(new THREE.Vector3(0, 28.5, 0));
          geometry.vertices.push(new THREE.Vector3(0, 28.5, 50));
          geometry.vertices.push(new THREE.Vector3(0, 0, 50));
          geometry.vertices.push(new THREE.Vector3(50, 0, 50));
          geometry.vertices.push(new THREE.Vector3(50, 0, 0));

          var line = new THREE.Line(geometry, lineMaterial);

          scene.add(line);

          // inner line

          var lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 1 });

          var geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3(50.1, 0.1, 50.1));
          geometry.vertices.push(new THREE.Vector3(50.1, 28.51, 50.1));
          geometry.vertices.push(new THREE.Vector3(0.1, 28.51, 50.1));
          geometry.vertices.push(new THREE.Vector3(50.1, 28.51, 50.1));
          geometry.vertices.push(new THREE.Vector3(50.1, 28.51, 0.1));
          var line = new THREE.Line(geometry, lineMaterial);

          scene.add(line);


          // point indicator
          /*
          geometry = new THREE.CubeGeometry( 5, 5, 5 );
          cubeMaterial = new THREE.MeshBasicMaterial( { color: 0xCC0000, wireframe: false, opacity: 1 } );

          mesh = new THREE.Mesh( geometry, cubeMaterial );

          mesh.position.x = 50;
          mesh.position.y = 25;
          mesh.position.z = 50;

          scene.add( mesh );
          */

          renderer = new THREE.WebGLRenderer({antialias: true});
          renderer.setSize( window.innerWidth, window.innerHeight );

          document.body.appendChild( renderer.domElement );

          stats = new Stats();
          stats.domElement.style.position = 'absolute';
          stats.domElement.style.top = '0px';
          container.appendChild( stats.domElement );



      }

      function animate() {
        var elapsed = Date.now() - start;
        if (elapsed > duration * 1000) {
          console.log("skipped")
          return;
        }

        requestAnimationFrame( animate );
        render();
        stats.update();


      }


      function render() {

        var timer = Date.now() * 0.0001;

        camera.position.x = 120; //Math.cos( timer ) * 200;
        camera.position.y = 120;
        camera.position.z = 120; //Math.sin( timer ) * 200;
        camera.lookAt( scene.position );

        renderer.render( scene, camera );

      }

    </script>
  </body>
</html>