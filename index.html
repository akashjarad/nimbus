<!DOCTYPE html>
<html>

  <head>
    <title>Nimbus</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <script src="js/three.min.js"></script>
    <script src="js/stats.min.js"></script>
  </head>

  <body>

<script>

      var container, stats;

      var camera, controls, scene, projector, renderer;
      var geometry, material, mesh;
      var objects = [], plane;

      var mouse = new THREE.Vector2(),
      offset = new THREE.Vector3(),
      INTERSECTED, SELECTED;

      init();
      animate();

      var start = Date.now();
      var rate = 10; // Hz
      var duration = 10; // s
      var lastFrameNumber;



      function init() {

          container = document.createElement( 'div' );
          document.body.appendChild( container );

          //camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 500, 1000 );

          camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000);


          scene = new THREE.Scene();



          // X AXIS IS RED
          var lineMaterial = new THREE.LineBasicMaterial({ color: 0xCC0000, linewidth: 5 });
          var geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3(0,0,0));
          geometry.vertices.push(new THREE.Vector3(500, 0, 0));
          var line = new THREE.Line(geometry, lineMaterial);
          scene.add(line);

          // Z AXIS IS GREEN
          var lineMaterial = new THREE.LineBasicMaterial({ color: 0x00CC00, linewidth: 5 });
          var geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3(0,0,0));
          geometry.vertices.push(new THREE.Vector3(0, 0, 500));
          var line = new THREE.Line(geometry, lineMaterial);
          scene.add(line);

          // Y AXIS IS BLUE
          var lineMaterial = new THREE.LineBasicMaterial({ color: 0x0000CC, linewidth: 5 });
          var geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3(0,0,0));
          geometry.vertices.push(new THREE.Vector3(0, 500, 0));
          var line = new THREE.Line(geometry, lineMaterial);
          scene.add(line);

          // Grid
          var size = 750, step = 75;
          var geometry = new THREE.Geometry();
          for ( var i = - size; i <= size; i += step ) {
            geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
            geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );
            geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
            geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );

          }
          var gridMaterial = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.1 } );
          var line = new THREE.Line( geometry, gridMaterial );
          line.type = THREE.LinePieces;
          scene.add( line );

          // Add some ambient light
          var ambientLight = new THREE.AmbientLight(0x555555);
          scene.add(ambientLight);

          // Cubes

          createCube(scene, 75, 42.75, 75, 0, -75, 0.6);
          createCube(scene, 75, 67.5, 175, 0, -75);


          createCube(scene, 75, 67.5, 275, 0, -75);
          createCube(scene, 75, 42.75, 375, 0, -75);
          createCube(scene, 75, 42.75, 75, 0, 175);
          createCube(scene, 75, 67.5, 175, 0, 175);
          createCube(scene, 75, 67.5, 275, 0, 175);
          createCube(scene, 75, 42.75, 375, 0, 175);

          createCube(scene, 75, 37.5, 75, 0, 275);
          createCube(scene, 75, 42.75, 175, 0, 275, 0.6);
          createCube(scene, 75, 67.5, 275, 0, 275, 0.6);
          createCube(scene, 75, 90, 375, 0, 275);

          createCube(scene, 75, 75, -175, 0, 275, 0.6);

          // point indicator
          /*
          geometry = new THREE.CubeGeometry( 5, 5, 5 );
          cubeMaterial = new THREE.MeshBasicMaterial( { color: 0xCC0000, wireframe: false, opacity: 1 } );

          mesh = new THREE.Mesh( geometry, cubeMaterial );

          mesh.position.x = 50;
          mesh.position.y = 25;
          mesh.position.z = 50;

          scene.add( mesh );
          */

          //plane = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.25, transparent: true, wireframe: true } ) );
          //plane.visible = false;
          //scene.add( plane );

          projector = new THREE.Projector();

          renderer = new THREE.WebGLRenderer( { antialias: true } );
          renderer.setSize( window.innerWidth, window.innerHeight );

          container.appendChild( renderer.domElement );

          stats = new Stats();
          stats.domElement.style.position = 'absolute';
          stats.domElement.style.top = '0px';
          container.appendChild( stats.domElement );

          renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );

          window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
        render();

      }

      function animate() {
        var elapsed = Date.now() - start;
        if (elapsed > duration * 1000) {
          //console.log("skipped")
          //return;
        }

        setTimeout( function() {
          requestAnimationFrame( animate );
        }, 1000 / rate );

        render();
        stats.update();
      }


      function render() {

        var timer = Date.now() * 0.0001;

        camera.position.x = 120; //Math.cos( timer ) * 200;
        camera.position.y = 94;
        camera.position.z = 120; //Math.sin( timer ) * 200;



        camera.position.x = 800; //Math.cos( timer ) * 200;
        camera.position.y = 500;
        camera.position.z = 800; //Math.sin( timer ) * 200;



        camera.lookAt( scene.position );

        renderer.render( scene, camera );

      }

      function createCube(scene, width, height, x, y, z, opacity) {

          // Defaults
          //var width = 50;
          //var height = 28.5;
          //var x = 75;
          //var z = 75;

          // Sit this on the plane
          y = y + height / 2;

          opacity = opacity || 1;

          // Container object
          var cube = new THREE.Object3D(); //create an empty container

          // Cube

          var geometry = new THREE.CubeGeometry( width, height, width );
          var cubeMaterial = new THREE.MeshBasicMaterial( { color: 0xE6E6E6, wireframe: false, opacity: opacity, transparent: true } );
          var cubeMesh = new THREE.Mesh( geometry, cubeMaterial );
          cubeMesh.position.x = x;
          cubeMesh.position.y = y;
          cubeMesh.position.z = z;
          cube.add( cubeMesh );

          // Outline

          var geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3(x + width/2, y - height/2, z - width/2)); // Bottom right corner
          geometry.vertices.push(new THREE.Vector3(x + width/2, y + height/2, z - width/2)); // Top right corner
          geometry.vertices.push(new THREE.Vector3(x - width/2, y + height/2, z - width/2)); // Top back corner
          geometry.vertices.push(new THREE.Vector3(x - width/2, y + height/2, z + width/2)); // Top left corner
          geometry.vertices.push(new THREE.Vector3(x - width/2, y - height/2, z + width/2)); // Bottom left corner
          geometry.vertices.push(new THREE.Vector3(x + width/2, y - height/2, z + width/2)); // Bottom front corner
          geometry.vertices.push(new THREE.Vector3(x + width/2, y - height/2, z - width/2)); // Bottom right corner

          var lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 6 });
          var line = new THREE.Line(geometry, lineMaterial);
          cube.add(line);

          // Inner lines

          var geometry = new THREE.Geometry();
          var clipBufferAmount = 0.1;
          geometry.vertices.push(new THREE.Vector3(x + width/2 + clipBufferAmount, y - height/2 + clipBufferAmount, z + width/2 + clipBufferAmount));
          geometry.vertices.push(new THREE.Vector3(x + width/2 + clipBufferAmount, y + height/2 + clipBufferAmount, z + width/2 + clipBufferAmount));
          geometry.vertices.push(new THREE.Vector3(x - width/2 + clipBufferAmount, y + height/2 + clipBufferAmount, z + width/2 + clipBufferAmount));
          geometry.vertices.push(new THREE.Vector3(x + width/2 + clipBufferAmount, y + height/2 + clipBufferAmount, z + width/2 + clipBufferAmount));
          geometry.vertices.push(new THREE.Vector3(x + width/2 + clipBufferAmount, y + height/2 + clipBufferAmount, z - width/2 + clipBufferAmount));

          var lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 });
          var line = new THREE.Line(geometry, lineMaterial);
          cube.add(line);

          // Back inner lines (occluded unless transparent)

          var geometry = new THREE.Geometry();
          var clipBufferAmount = 0.1;
          geometry.vertices.push(new THREE.Vector3(x - width/2 - clipBufferAmount, y + height/2 + clipBufferAmount, z - width/2 - clipBufferAmount));
          geometry.vertices.push(new THREE.Vector3(x - width/2 - clipBufferAmount, y - height/2 - clipBufferAmount, z - width/2 - clipBufferAmount));
          geometry.vertices.push(new THREE.Vector3(x - width/2 - clipBufferAmount, y - height/2 - clipBufferAmount, z + width/2 + clipBufferAmount));
          geometry.vertices.push(new THREE.Vector3(x - width/2 - clipBufferAmount, y - height/2 - clipBufferAmount, z - width/2 - clipBufferAmount));
          geometry.vertices.push(new THREE.Vector3(x + width/2 + clipBufferAmount, y - height/2 - clipBufferAmount, z - width/2 - clipBufferAmount));

          var lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 });
          var line = new THREE.Line(geometry, lineMaterial);
          cube.add(line);

          // Add square logo to top of the cube

          // Calculate size & position of the square, relative to the cube size
          var squareSize = width * 0.1333333333;
          var squareBorderSpacing = squareSize * 0.6;
          var squarePosX = x + width / 2 - squareSize - squareBorderSpacing;
          var squarePosY = y + clipBufferAmount*2 + height / 2;
          var squarePosZ = z + width / 2 - squareSize - squareBorderSpacing;

          var squareGeometry = new THREE.Geometry();
          squareGeometry.vertices.push(new THREE.Vector3(-1 * squareSize, 0, squareSize));
          squareGeometry.vertices.push(new THREE.Vector3(squareSize, 0,  squareSize));
          squareGeometry.vertices.push(new THREE.Vector3(squareSize, 0, -1 * squareSize));
          squareGeometry.vertices.push(new THREE.Vector3(-1 * squareSize, 0, -1 * squareSize));
          squareGeometry.faces.push(new THREE.Face4(0, 1, 2, 3));

          var squareMaterial = new THREE.MeshBasicMaterial( { color: 0x707071, side: THREE.DoubleSide, opacity: opacity, transparent: true } );
          var squareMesh = new THREE.Mesh(squareGeometry, squareMaterial);
          squareMesh.position.set(squarePosX, squarePosY, squarePosZ);
          cube.add( squareMesh );

          // Add cube object to the scene
          scene.add( cube );

          // and our list of objects
          objects.push( cubeMesh );

      }


      function onDocumentMouseMove( event ) {

        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        //

        console.log (mouse.x + " " + mouse.y)

        var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
        projector.unprojectVector( vector, camera );

        var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

        if ( SELECTED ) {

          var intersects = raycaster.intersectObject( plane );
          SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );
          return;

        }


        var intersects = raycaster.intersectObjects( objects, true );

        console.log(intersects)

        if ( intersects.length > 0 ) {

          console.log('yup!');

          if ( INTERSECTED != intersects[ 0 ].object ) {

            if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

            INTERSECTED = intersects[ 0 ].object;
            INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

            INTERSECTED.material.color.setHex(130000)

            plane.position.copy( INTERSECTED.position );
            plane.lookAt( camera.position );

          }

          container.style.cursor = 'pointer';

        } else {

          if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

          INTERSECTED = null;

          container.style.cursor = 'auto';

        }

      }


    </script>
  </body>
</html>