<!DOCTYPE html>
<html>

  <head>
    <title>Nimbus</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <script src="js/three.min.js"></script>
    <script src="js/stats.min.js"></script>
  </head>

  <body>

<script>

      var container, stats;

      var camera, scene, renderer;
      var geometry, material, mesh;

      init();
      animate();

      var start = Date.now();
      var rate = 10; // Hz
      var duration = 10; // s
      var lastFrameNumber;



      function init() {

          container = document.createElement( 'div' );
          document.body.appendChild( container );

          camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 500, 1000 );
          camera.position.x = 200;
          camera.position.y = 100;
          camera.position.z = 200;

          scene = new THREE.Scene();


          // X AXIS IS RED
          var lineMaterial = new THREE.LineBasicMaterial({ color: 0xCC0000, linewidth: 5 });
          var geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3(0,0,0));
          geometry.vertices.push(new THREE.Vector3(500, 0, 0));
          var line = new THREE.Line(geometry, lineMaterial);
          scene.add(line);

          // Z AXIS IS GREEN
          var lineMaterial = new THREE.LineBasicMaterial({ color: 0x00CC00, linewidth: 5 });
          var geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3(0,0,0));
          geometry.vertices.push(new THREE.Vector3(0, 0, 500));
          var line = new THREE.Line(geometry, lineMaterial);
          scene.add(line);

          // Y AXIS IS BLUE
          var lineMaterial = new THREE.LineBasicMaterial({ color: 0x0000CC, linewidth: 5 });
          var geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3(0,0,0));
          geometry.vertices.push(new THREE.Vector3(0, 500, 0));
          var line = new THREE.Line(geometry, lineMaterial);
          scene.add(line);


          // Grid

          var size = 750, step = 75;

          var geometry = new THREE.Geometry();

          for ( var i = - size; i <= size; i += step ) {

            geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
            geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );

            geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
            geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );

          }

          var gridMaterial = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.1 } );
          var line = new THREE.Line( geometry, gridMaterial );
          line.type = THREE.LinePieces;
          scene.add( line );



          var pointLight =
          new THREE.PointLight(0xFFFFFF);

          // set its position
          pointLight.position.x = 500;
          pointLight.position.y = 500;
          pointLight.position.z = 500;

          // add to the scene
          scene.add(pointLight);

          var ambientLight = new THREE.AmbientLight(0x555555);
          scene.add(ambientLight);

          // Cubes

          createCube(scene, 75, 42.75, 75, 0, -75);
          createCube(scene, 75, 67.5, 175, 0, -75);
          createCube(scene, 75, 67.5, 275, 0, -75);
          createCube(scene, 75, 42.75, 375, 0, -75);
          createCube(scene, 75, 42.75, 75, 0, 175);
          createCube(scene, 75, 67.5, 175, 0, 175);
          createCube(scene, 75, 67.5, 275, 0, 175);
          createCube(scene, 75, 42.75, 375, 0, 175);

          createCube(scene, 75, 37.5, 75, 0, 275);
          createCube(scene, 75, 42.75, 175, 0, 275);
          createCube(scene, 75, 67.5, 275, 0, 275);
          createCube(scene, 75, 90, 375, 0, 275);

          // point indicator
          /*
          geometry = new THREE.CubeGeometry( 5, 5, 5 );
          cubeMaterial = new THREE.MeshBasicMaterial( { color: 0xCC0000, wireframe: false, opacity: 1 } );

          mesh = new THREE.Mesh( geometry, cubeMaterial );

          mesh.position.x = 50;
          mesh.position.y = 25;
          mesh.position.z = 50;

          scene.add( mesh );
          */

          renderer = new THREE.CanvasRenderer();
          renderer.setSize( window.innerWidth, window.innerHeight );

          document.body.appendChild( renderer.domElement );

          stats = new Stats();
          stats.domElement.style.position = 'absolute';
          stats.domElement.style.top = '0px';
          container.appendChild( stats.domElement );



      }

      function animate() {
        var elapsed = Date.now() - start;
        if (elapsed > duration * 1000) {
          console.log("skipped")
          return;
        }

        requestAnimationFrame( animate );
        render();
        stats.update();


      }


      function render() {

        var timer = Date.now() * 0.0001;

        camera.position.x = 120; //Math.cos( timer ) * 200;
        camera.position.y = 120;
        camera.position.z = 120; //Math.sin( timer ) * 200;
        camera.lookAt( scene.position );

        renderer.render( scene, camera );

      }

      function createCube(scene, width, height, x, y, z, opacity) {

          // Defaults
          //var width = 50;
          //var height = 28.5;
          //var x = 75;
          //var z = 75;

          // Sit this on the plane
          y = y + height / 2;

          opacity = opacity || 1;

          // Container object
          cube = new THREE.Object3D();//create an empty container

          // Cube

          geometry = new THREE.CubeGeometry( width, height, width );
          cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xEBEBEC, wireframe: false, opacity: opacity } );
          mesh = new THREE.Mesh( geometry, cubeMaterial );
          mesh.position.x = x;
          mesh.position.y = y;
          mesh.position.z = z;
          cube.add( mesh );

          // Outline

          var geometry = new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3(x + width/2, y - height/2, z - width/2)); // Bottom right corner
          geometry.vertices.push(new THREE.Vector3(x + width/2, y + height/2, z - width/2)); // Top right corner
          geometry.vertices.push(new THREE.Vector3(x - width/2, y + height/2, z - width/2)); // Top back corner
          geometry.vertices.push(new THREE.Vector3(x - width/2, y + height/2, z + width/2)); // Top left corner
          geometry.vertices.push(new THREE.Vector3(x - width/2, y - height/2, z + width/2)); // Bottom left corner
          geometry.vertices.push(new THREE.Vector3(x + width/2, y - height/2, z + width/2)); // Bottom front corner
          geometry.vertices.push(new THREE.Vector3(x + width/2, y - height/2, z - width/2)); // Bottom right corner

          var lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 6 });
          var line = new THREE.Line(geometry, lineMaterial);
          cube.add(line);

          // Inner lines

          var geometry = new THREE.Geometry();
          var clipBufferAmount = 0.1;
          geometry.vertices.push(new THREE.Vector3(x + width/2 + clipBufferAmount, y - height/2 + clipBufferAmount, z + width/2 + clipBufferAmount));
          geometry.vertices.push(new THREE.Vector3(x + width/2 + clipBufferAmount, y + height/2 + clipBufferAmount, z + width/2 + clipBufferAmount));
          geometry.vertices.push(new THREE.Vector3(x - width/2 + clipBufferAmount, y + height/2 + clipBufferAmount, z + width/2 + clipBufferAmount));
          geometry.vertices.push(new THREE.Vector3(x + width/2 + clipBufferAmount, y + height/2 + clipBufferAmount, z + width/2 + clipBufferAmount));
          geometry.vertices.push(new THREE.Vector3(x + width/2 + clipBufferAmount, y + height/2 + clipBufferAmount, z - width/2 + clipBufferAmount));

          var lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 });
          var line = new THREE.Line(geometry, lineMaterial);
          cube.add(line);

          // Add square logo to top of the cube

          // Calculate size & position of the square, relative to the cube size
          var squareSize = width * 0.1333333333;
          var squareBorderSpacing = squareSize * 0.6;
          var squarePosX = x + width / 2 - squareSize - squareBorderSpacing;
          var squarePosY = y + clipBufferAmount + height / 2;
          var squarePosZ = z + width / 2 - squareSize - squareBorderSpacing;

          var squareGeometry = new THREE.Geometry();
          squareGeometry.vertices.push(new THREE.Vector3(-1 * squareSize, 0, squareSize));
          squareGeometry.vertices.push(new THREE.Vector3(squareSize, 0,  squareSize));
          squareGeometry.vertices.push(new THREE.Vector3(squareSize, 0, -1 * squareSize));
          squareGeometry.vertices.push(new THREE.Vector3(-1 * squareSize, 0, -1 * squareSize));
          squareGeometry.faces.push(new THREE.Face4(0, 1, 2, 3));

          var squareMaterial = new THREE.MeshBasicMaterial( { color: 0x707071, side: THREE.DoubleSide, opacity: opacity } );
          var squareMesh = new THREE.Mesh(squareGeometry, squareMaterial);
          squareMesh.position.set(squarePosX, squarePosY, squarePosZ);
          cube.add( squareMesh );

          // Add cube object to the scene
          scene.add( cube );

      }

    </script>
  </body>
</html>